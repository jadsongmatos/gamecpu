#version 450
#extension GL_ARB_gpu_shader_int64 : require

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set=0, binding=0, std140) uniform Globals {
    uint width;
    uint height;
    uint pitch_pixels;
    uint tiles_x;

    uint tiles_y;
    uint num_tiles;
    uint clear_color_bgra;
    uint _pad0;

    int cx2;
    int cy2;
    int focal_x_q16;
    int focal_y_q16;

    int sin_y_q15;
    int cos_y_q15;
    int cam_z_q16;
    int near_q16;

    int center_x_q16;
    int center_y_q16;
    int center_z_q16;
    int scale_x_q16;
    int scale_y_q16;
    int scale_z_q16;
} g;

struct TriSetup {
    uint minx; uint maxx; uint miny; uint maxy;
    int e0a; int e0b; int e0c;
    int e1a; int e1b; int e1c;
    int e2a; int e2b; int e2c;
    int xref; int yref;
    int zref_q16;
    int dzdx_q16;
    int dzdy_q16;
    uint rgba;
    uint _padA;

    int uref; int du_dx; int du_dy;
    int vref; int dv_dx; int dv_dy;
    uint _padB; uint _padC;
    uint _padD; uint _padE; uint _padF; uint _padG;
};

layout(set=0, binding=1, std430) readonly buffer TriSetupBuf { TriSetup ts[]; };
layout(set=0, binding=2, std430) readonly buffer TileCounts { uint tile_counts[]; };
layout(set=0, binding=3, std430) readonly buffer TileTriIds { uint tile_tri_ids[]; };
layout(set=0, binding=4, std430) buffer ColorBuf { uint color[]; };
layout(set=0, binding=5, std430) buffer DepthBuf { uint depth[]; };
layout(set=0, binding=6) uniform texture2D t_diffuse;
layout(set=0, binding=7) uniform sampler s_diffuse;

const uint TILE_W = 8u;
const uint TILE_H = 8u;
const uint MAX_TRIS_PER_TILE = 256u;

void main() {
    uint tx = gl_WorkGroupID.x, ty = gl_WorkGroupID.y;
    uint x = tx * TILE_W + gl_LocalInvocationID.x;
    uint y = ty * TILE_H + gl_LocalInvocationID.y;
    if (x >= g.width || y >= g.height) return;

    uint pix = y * g.pitch_pixels + x;
    uint bestZ = depth[pix];
    uint bestC = color[pix];
    uint tile = ty * g.tiles_x + tx;
    uint count = min(tile_counts[tile], MAX_TRIS_PER_TILE);
    int px2 = int(x * 2u + 1u), py2 = int(y * 2u + 1u);

    for (uint i = 0u; i < count; ++i) {
        TriSetup t = ts[tile_tri_ids[tile * MAX_TRIS_PER_TILE + i]];
        if (t.minx > t.maxx || x < t.minx || x > t.maxx || y < t.miny || y > t.maxy) continue;
        if (t.e0a * px2 + t.e0b * py2 + t.e0c >= 0 && t.e1a * px2 + t.e1b * py2 + t.e1c >= 0 && t.e2a * px2 + t.e2b * py2 + t.e2c >= 0) {
            int64_t z = int64_t(t.zref_q16) + int64_t(t.dzdx_q16) * int64_t(int(x) - t.xref) + int64_t(t.dzdy_q16) * int64_t(int(y) - t.yref);
            if (uint(z) < bestZ) { 
                bestZ = uint(z); 
                
                // Interpolate UV
                int64_t u_int = int64_t(t.uref) + int64_t(t.du_dx) * int64_t(int(x) - t.xref) + int64_t(t.du_dy) * int64_t(int(y) - t.yref);
                int64_t v_int = int64_t(t.vref) + int64_t(t.dv_dx) * int64_t(int(x) - t.xref) + int64_t(t.dv_dy) * int64_t(int(y) - t.yref);
                
                vec2 uv = vec2(float(u_int) / 65535.0, float(v_int) / 65535.0);
                vec4 texColor = textureLod(sampler2D(t_diffuse, s_diffuse), uv, 0.0);
                
                // Convert vec4 to bgra uint
                uint r = uint(texColor.r * 255.0);
                uint g = uint(texColor.g * 255.0);
                uint b = uint(texColor.b * 255.0);
                uint a = uint(texColor.a * 255.0);
                bestC = (a << 24) | (r << 16) | (g << 8) | b;
            }
        }
    }
    depth[pix] = bestZ; color[pix] = bestC;
}
